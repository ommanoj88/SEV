# Deep Dive: Historical Data Analysis

**Date:** 2025-11-19
**Feature:** Historical Data Analysis
**Status:** ⚠️ **Partial Implementation - Data Exists, Analytics Missing**

This report analyzes the implementation of historical data analysis functionality for long-term fleet performance tracking, trend analysis, and predictive insights.

## 1. Executive Summary

The application **collects historical data** through various modules (trips, maintenance, charging, etc.) and aggregates daily summaries in `FleetSummary`, but lacks comprehensive historical analysis capabilities, trend detection, comparative analysis, and predictive analytics that are essential for strategic fleet management.

**Current State:**
- ✅ Data Collection: Historical data stored in multiple tables
- ✅ Basic Aggregation: Daily `FleetSummary` records
- ⚠️ Limited Querying: Can retrieve date ranges but minimal analysis
- ❌ Trend Analysis: No trend detection or pattern recognition
- ❌ Comparative Analysis: No period-over-period comparisons
- ❌ Predictive Analytics: No forecasting capabilities
- ❌ Anomaly Detection: No unusual pattern identification
- ❌ Historical Reports: No long-term performance reports

**Impact:** Fleet managers can see what happened but cannot understand trends, predict future needs, or make data-driven strategic decisions.

---

## 2. Current Data Collection Status

### 2.1 Existing Historical Data Tables

#### ✅ Fleet Summaries (Aggregated Daily)
**Table:** `fleet_summaries`
**Data Retained:** Daily summaries per company
**Fields:**
- Total vehicles, active vehicles
- Total trips, distance
- Energy consumed, costs (energy, fuel, maintenance)
- Date: `summary_date`

**Retention:** Indefinite (no archival/cleanup policy)

#### ✅ Trip History
**Table:** `trips`
**Data Retained:** All trips
**Fields:**
- Vehicle, driver, start/end times
- Distance, duration
- Start/end locations
- Status

**Retention:** Indefinite

#### ✅ Maintenance History
**Table:** `maintenance_schedules`
**Data Retained:** All maintenance records
**Fields:**
- Vehicle, scheduled date, completed date
- Type, cost, description
- Service provider
- Status

**Retention:** Indefinite

#### ✅ Charging History
**Table:** `charging_sessions`
**Data Retained:** All charging sessions
**Fields:**
- Vehicle, station, start/end times
- Energy consumed, cost
- Status

**Retention:** Indefinite

#### ✅ Driver Performance History
**Table:** `driver_performance` (from D3 analysis)
**Data Retained:** Performance metrics per driver
**Fields:**
- Driver ID, date
- Safety score, efficiency score
- Total distance, trip count

**Retention:** Indefinite

### 2.2 Missing Historical Tables

#### ❌ Vehicle State History
**Purpose:** Track vehicle state changes over time
**Missing Table:** `vehicle_state_history`

**Required Schema:**
```sql
CREATE TABLE vehicle_state_history (
    id BIGSERIAL PRIMARY KEY,
    vehicle_id BIGINT NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    
    -- Location
    latitude NUMERIC(10, 6),
    longitude NUMERIC(10, 6),
    
    -- Battery/Fuel state
    battery_level INTEGER,           -- % for EVs
    fuel_level INTEGER,              -- % for ICE/Hybrid
    
    -- Movement
    speed NUMERIC(10, 2),            -- km/h
    odometer NUMERIC(10, 2),         -- km
    
    -- Status
    status VARCHAR(50),              -- IDLE, MOVING, CHARGING, MAINTENANCE
    ignition_status BOOLEAN,
    
    -- Health indicators
    battery_health INTEGER,          -- % for EVs
    tire_pressure JSONB,             -- Array of 4 values
    
    FOREIGN KEY (vehicle_id) REFERENCES vehicles(id) ON DELETE CASCADE
);

CREATE INDEX idx_vehicle_state_history_vehicle ON vehicle_state_history(vehicle_id);
CREATE INDEX idx_vehicle_state_history_timestamp ON vehicle_state_history(timestamp);
```

**Retention Policy:** Keep detailed records for 90 days, then aggregate to hourly snapshots

#### ❌ Cost History by Category
**Purpose:** Track costs over time by category
**Missing Table:** `cost_history`

**Required Schema:**
```sql
CREATE TABLE cost_history (
    id BIGSERIAL PRIMARY KEY,
    company_id BIGINT NOT NULL,
    vehicle_id BIGINT,               -- NULL for company-wide
    date DATE NOT NULL,
    
    -- Cost categories
    fuel_cost NUMERIC(10, 2) DEFAULT 0,
    energy_cost NUMERIC(10, 2) DEFAULT 0,
    maintenance_cost NUMERIC(10, 2) DEFAULT 0,
    insurance_cost NUMERIC(10, 2) DEFAULT 0,
    registration_cost NUMERIC(10, 2) DEFAULT 0,
    parking_cost NUMERIC(10, 2) DEFAULT 0,
    toll_cost NUMERIC(10, 2) DEFAULT 0,
    depreciation_cost NUMERIC(10, 2) DEFAULT 0,
    other_cost NUMERIC(10, 2) DEFAULT 0,
    
    -- Totals
    total_cost NUMERIC(10, 2) NOT NULL,
    
    -- Metadata
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(company_id, vehicle_id, date)
);

CREATE INDEX idx_cost_history_company ON cost_history(company_id);
CREATE INDEX idx_cost_history_vehicle ON cost_history(vehicle_id);
CREATE INDEX idx_cost_history_date ON cost_history(date);
```

#### ❌ Utilization History
**Purpose:** Track vehicle utilization over time
**Missing Table:** `utilization_history`

**Required Schema:**
```sql
CREATE TABLE utilization_history (
    id BIGSERIAL PRIMARY KEY,
    vehicle_id BIGINT NOT NULL,
    date DATE NOT NULL,
    
    -- Time allocation (in minutes)
    active_time INTEGER DEFAULT 0,           -- Vehicle in use
    idle_time INTEGER DEFAULT 0,             -- Vehicle on but not moving
    charging_time INTEGER DEFAULT 0,         -- Vehicle charging
    maintenance_time INTEGER DEFAULT 0,      -- Vehicle in maintenance
    available_time INTEGER DEFAULT 0,        -- Vehicle available but unused
    
    -- Utilization metrics
    utilization_rate NUMERIC(5, 2),          -- % of time actively used
    idle_rate NUMERIC(5, 2),                 -- % of time idle
    
    -- Trip metrics
    trip_count INTEGER DEFAULT 0,
    total_distance NUMERIC(10, 2) DEFAULT 0,
    average_trip_distance NUMERIC(10, 2),
    
    -- Calculated at end of day
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (vehicle_id) REFERENCES vehicles(id) ON DELETE CASCADE,
    UNIQUE(vehicle_id, date)
);

CREATE INDEX idx_utilization_history_vehicle ON utilization_history(vehicle_id);
CREATE INDEX idx_utilization_history_date ON utilization_history(date);
```

#### ❌ Fleet Metrics History
**Purpose:** Track key performance indicators over time
**Missing Table:** `fleet_metrics_history`

**Required Schema:**
```sql
CREATE TABLE fleet_metrics_history (
    id BIGSERIAL PRIMARY KEY,
    company_id BIGINT NOT NULL,
    metric_date DATE NOT NULL,
    
    -- Fleet size metrics
    total_vehicles INTEGER,
    active_vehicles INTEGER,
    inactive_vehicles INTEGER,
    vehicles_in_maintenance INTEGER,
    vehicles_charging INTEGER,
    
    -- Performance metrics
    fleet_utilization_rate NUMERIC(5, 2),
    average_vehicle_efficiency NUMERIC(10, 4),
    total_fleet_distance NUMERIC(10, 2),
    
    -- Cost metrics
    cost_per_vehicle NUMERIC(10, 2),
    cost_per_km NUMERIC(10, 4),
    total_operational_cost NUMERIC(10, 2),
    
    -- Environmental metrics
    total_co2_saved NUMERIC(10, 2),          -- kg vs ICE fleet
    total_energy_consumed NUMERIC(10, 2),    -- kWh
    
    -- Driver metrics
    total_drivers INTEGER,
    average_driver_score NUMERIC(5, 2),
    
    -- Created timestamp
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(company_id, metric_date)
);

CREATE INDEX idx_fleet_metrics_company ON fleet_metrics_history(company_id);
CREATE INDEX idx_fleet_metrics_date ON fleet_metrics_history(metric_date);
```

---

## 3. Required Historical Analysis Features

### 3.1 Trend Analysis

**Purpose:** Identify patterns and trends over time

**Features Needed:**

#### A. Cost Trends
- **Monthly/Quarterly/Yearly cost trends**
  - Total cost over time
  - Cost per vehicle over time
  - Cost per kilometer over time
  - Cost by category (fuel, maintenance, etc.)
- **Trend direction:** Increasing, Decreasing, Stable
- **Rate of change:** % increase/decrease month-over-month
- **Forecasting:** Predicted costs for next period
- **Alerts:** Notify if costs increase >10% month-over-month

#### B. Utilization Trends
- **Fleet utilization over time**
- **Per-vehicle utilization patterns**
- **Peak usage periods** (time of day, day of week, season)
- **Underutilized vehicles** (consistently low usage)
- **Overutilized vehicles** (high wear and tear risk)

#### C. Efficiency Trends
- **Energy efficiency over time** (kWh/100km)
- **Fuel efficiency over time** (L/100km)
- **Identifying degradation** (battery health, engine performance)
- **Best/worst performing vehicles**
- **Driver efficiency trends**

#### D. Maintenance Trends
- **Maintenance frequency over time**
- **Maintenance cost trends**
- **Common failure points**
- **Predictive maintenance** (forecast upcoming needs)
- **Vehicle reliability scores**

### 3.2 Comparative Analysis

**Purpose:** Compare performance across different dimensions

**Comparisons Needed:**

#### A. Period-over-Period
- **Month-over-Month:** Compare current month to previous month
- **Quarter-over-Quarter:** Compare current quarter to previous quarter
- **Year-over-Year:** Compare current year to same month last year
- **Custom Periods:** Compare any two time periods

**Metrics to Compare:**
- Total cost
- Distance traveled
- Energy/Fuel consumed
- Maintenance events
- Driver performance
- Fleet utilization

#### B. Vehicle-to-Vehicle
- Compare individual vehicles on same metrics
- Identify best/worst performers
- Group by vehicle type, age, model

#### C. Fleet Benchmarking
- Compare fleet performance to:
  - Industry averages
  - Historical fleet performance
  - Peer fleets (if available)

### 3.3 Predictive Analytics

**Purpose:** Forecast future trends and needs

**Predictions Needed:**

#### A. Cost Forecasting
- **Next month/quarter/year cost prediction**
- Based on historical trends
- Factor in seasonality
- Confidence intervals

#### B. Maintenance Forecasting
- **Predict next maintenance date**
- Based on historical patterns and current odometer
- Predict maintenance type and cost

#### C. Utilization Forecasting
- **Predict future fleet demand**
- Identify when to add/remove vehicles
- Optimize fleet size

#### D. Battery Life Prediction (EVs)
- **Predict remaining battery life**
- Based on usage patterns and charge cycles
- Recommend replacement timing

### 3.4 Anomaly Detection

**Purpose:** Identify unusual patterns requiring attention

**Anomalies to Detect:**

#### A. Cost Anomalies
- Sudden cost spikes
- Unusual cost patterns
- Vehicles with abnormally high costs

#### B. Performance Anomalies
- Sudden efficiency drop
- Unusual trip patterns
- Unexpected downtime

#### C. Behavioral Anomalies
- Driver behavior changes
- Unusual route deviations
- Abnormal energy consumption

---

## 4. Backend Implementation Requirements

### 4.1 Service Layer

**File:** `backend/evfleet-monolith/src/main/java/com/evfleet/analytics/service/HistoricalAnalyticsService.java`

```java
package com.evfleet.analytics.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

@Service
@Slf4j
@RequiredArgsConstructor
public class HistoricalAnalyticsService {
    
    private final FleetSummaryRepository fleetSummaryRepository;
    private final TripRepository tripRepository;
    private final MaintenanceRepository maintenanceRepository;
    private final ChargingSessionRepository chargingSessionRepository;
    
    /**
     * Get historical cost trends
     */
    public CostTrendAnalysis getCostTrend(
        Long companyId,
        LocalDate startDate,
        LocalDate endDate,
        TrendGranularity granularity
    ) {
        // Query historical cost data
        List<FleetSummary> summaries = fleetSummaryRepository
            .findByCompanyIdAndSummaryDateBetween(companyId, startDate, endDate);
        
        // Aggregate by granularity (daily, weekly, monthly)
        List<CostDataPoint> dataPoints = aggregateCostData(summaries, granularity);
        
        // Calculate trend metrics
        TrendMetrics metrics = calculateTrendMetrics(dataPoints);
        
        // Forecast next period
        ForecastResult forecast = forecastCosts(dataPoints);
        
        return CostTrendAnalysis.builder()
            .dataPoints(dataPoints)
            .metrics(metrics)
            .forecast(forecast)
            .build();
    }
    
    /**
     * Get utilization trends
     */
    public UtilizationTrendAnalysis getUtilizationTrend(
        Long vehicleId,
        LocalDate startDate,
        LocalDate endDate
    ) {
        // Query trip history
        List<Trip> trips = tripRepository.findByVehicleIdAndDateRange(vehicleId, startDate, endDate);
        
        // Calculate daily utilization
        List<UtilizationDataPoint> dataPoints = calculateDailyUtilization(trips);
        
        // Identify patterns
        UsagePatterns patterns = identifyUsagePatterns(dataPoints);
        
        return UtilizationTrendAnalysis.builder()
            .dataPoints(dataPoints)
            .patterns(patterns)
            .averageUtilization(calculateAverage(dataPoints))
            .peakUsageTimes(patterns.getPeakTimes())
            .build();
    }
    
    /**
     * Compare two time periods
     */
    public PeriodComparison comparePeriods(
        Long companyId,
        LocalDate period1Start,
        LocalDate period1End,
        LocalDate period2Start,
        LocalDate period2End
    ) {
        // Get metrics for both periods
        PeriodMetrics period1Metrics = calculatePeriodMetrics(companyId, period1Start, period1End);
        PeriodMetrics period2Metrics = calculatePeriodMetrics(companyId, period2Start, period2End);
        
        // Calculate differences
        MetricsDiff diff = calculateDifferences(period1Metrics, period2Metrics);
        
        return PeriodComparison.builder()
            .period1(period1Metrics)
            .period2(period2Metrics)
            .differences(diff)
            .percentChanges(calculatePercentChanges(diff))
            .build();
    }
    
    /**
     * Detect anomalies in historical data
     */
    public List<Anomaly> detectAnomalies(
        Long companyId,
        LocalDate startDate,
        LocalDate endDate,
        AnomalyType type
    ) {
        // Get historical data
        List<FleetSummary> summaries = fleetSummaryRepository
            .findByCompanyIdAndSummaryDateBetween(companyId, startDate, endDate);
        
        // Calculate baseline (mean and standard deviation)
        StatisticalBaseline baseline = calculateBaseline(summaries);
        
        // Identify outliers (values >2 standard deviations from mean)
        List<Anomaly> anomalies = identifyOutliers(summaries, baseline);
        
        // Filter by type
        return anomalies.stream()
            .filter(a -> a.getType() == type)
            .collect(Collectors.toList());
    }
    
    /**
     * Forecast future metrics
     */
    public ForecastResult forecastMetrics(
        Long companyId,
        MetricType metricType,
        Integer daysAhead
    ) {
        // Get historical data (last 90 days minimum)
        LocalDate endDate = LocalDate.now();
        LocalDate startDate = endDate.minusDays(90);
        
        List<FleetSummary> summaries = fleetSummaryRepository
            .findByCompanyIdAndSummaryDateBetween(companyId, startDate, endDate);
        
        // Extract metric values
        List<Double> values = extractMetricValues(summaries, metricType);
        
        // Apply forecasting algorithm (simple moving average, linear regression, or ARIMA)
        ForecastResult forecast = applyForecasting(values, daysAhead);
        
        return forecast;
    }
    
    /**
     * Get fleet health score over time
     */
    public HealthScoreTrend getFleetHealthTrend(
        Long companyId,
        LocalDate startDate,
        LocalDate endDate
    ) {
        // Calculate health score for each day
        List<HealthScoreDataPoint> dataPoints = new ArrayList<>();
        
        for (LocalDate date = startDate; !date.isAfter(endDate); date = date.plusDays(1)) {
            HealthScoreDataPoint point = calculateDailyHealthScore(companyId, date);
            dataPoints.add(point);
        }
        
        // Identify health trends
        HealthTrend trend = analyzeHealthTrend(dataPoints);
        
        return HealthScoreTrend.builder()
            .dataPoints(dataPoints)
            .trend(trend)
            .currentScore(dataPoints.get(dataPoints.size() - 1).getScore())
            .build();
    }
    
    // Private helper methods
    private List<CostDataPoint> aggregateCostData(List<FleetSummary> summaries, TrendGranularity granularity) { /* ... */ }
    private TrendMetrics calculateTrendMetrics(List<CostDataPoint> dataPoints) { /* ... */ }
    private ForecastResult forecastCosts(List<CostDataPoint> dataPoints) { /* ... */ }
    private List<UtilizationDataPoint> calculateDailyUtilization(List<Trip> trips) { /* ... */ }
    private UsagePatterns identifyUsagePatterns(List<UtilizationDataPoint> dataPoints) { /* ... */ }
    private PeriodMetrics calculatePeriodMetrics(Long companyId, LocalDate start, LocalDate end) { /* ... */ }
    private MetricsDiff calculateDifferences(PeriodMetrics p1, PeriodMetrics p2) { /* ... */ }
    private StatisticalBaseline calculateBaseline(List<FleetSummary> summaries) { /* ... */ }
    private List<Anomaly> identifyOutliers(List<FleetSummary> summaries, StatisticalBaseline baseline) { /* ... */ }
    private List<Double> extractMetricValues(List<FleetSummary> summaries, MetricType type) { /* ... */ }
    private ForecastResult applyForecasting(List<Double> values, Integer daysAhead) { /* ... */ }
    private HealthScoreDataPoint calculateDailyHealthScore(Long companyId, LocalDate date) { /* ... */ }
    private HealthTrend analyzeHealthTrend(List<HealthScoreDataPoint> dataPoints) { /* ... */ }
}
```

### 4.2 Data Aggregation Job

**Purpose:** Pre-calculate historical metrics daily for performance

```java
@Component
@Slf4j
@RequiredArgsConstructor
public class HistoricalDataAggregationJob {
    
    private final HistoricalAnalyticsService historicalAnalyticsService;
    
    /**
     * Aggregate previous day's data every night at 1 AM
     */
    @Scheduled(cron = "0 0 1 * * *")
    public void aggregateDailyData() {
        log.info("Starting daily data aggregation job");
        
        LocalDate yesterday = LocalDate.now().minusDays(1);
        
        try {
            // Aggregate cost history
            historicalAnalyticsService.aggregateDailyCosts(yesterday);
            
            // Aggregate utilization metrics
            historicalAnalyticsService.aggregateDailyUtilization(yesterday);
            
            // Aggregate fleet metrics
            historicalAnalyticsService.aggregateDailyFleetMetrics(yesterday);
            
            // Calculate health scores
            historicalAnalyticsService.calculateDailyHealthScores(yesterday);
            
            log.info("Daily data aggregation completed successfully");
        } catch (Exception e) {
            log.error("Error during daily data aggregation", e);
        }
    }
    
    /**
     * Clean up old detailed data (keep aggregates)
     */
    @Scheduled(cron = "0 0 3 1 * *")  // 3 AM on 1st of each month
    public void archiveOldData() {
        log.info("Starting data archival job");
        
        LocalDate archiveDate = LocalDate.now().minusDays(90);
        
        try {
            // Archive vehicle state history (keep last 90 days detailed)
            historicalAnalyticsService.archiveVehicleStateHistory(archiveDate);
            
            log.info("Data archival completed successfully");
        } catch (Exception e) {
            log.error("Error during data archival", e);
        }
    }
}
```

### 4.3 API Endpoints

**Add to `AnalyticsController.java`:**

```java
@GetMapping("/historical/cost-trend")
@Operation(summary = "Get historical cost trend analysis")
public ResponseEntity<ApiResponse<CostTrendAnalysis>> getCostTrend(
    @RequestParam Long companyId,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate,
    @RequestParam(defaultValue = "DAILY") TrendGranularity granularity) {
    
    CostTrendAnalysis trend = historicalAnalyticsService.getCostTrend(
        companyId, startDate, endDate, granularity);
    return ResponseEntity.ok(ApiResponse.success("Cost trend retrieved", trend));
}

@GetMapping("/historical/utilization-trend/{vehicleId}")
@Operation(summary = "Get vehicle utilization trend")
public ResponseEntity<ApiResponse<UtilizationTrendAnalysis>> getUtilizationTrend(
    @PathVariable Long vehicleId,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
    
    UtilizationTrendAnalysis trend = historicalAnalyticsService.getUtilizationTrend(
        vehicleId, startDate, endDate);
    return ResponseEntity.ok(ApiResponse.success("Utilization trend retrieved", trend));
}

@GetMapping("/historical/compare-periods")
@Operation(summary = "Compare two time periods")
public ResponseEntity<ApiResponse<PeriodComparison>> comparePeriods(
    @RequestParam Long companyId,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate period1Start,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate period1End,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate period2Start,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate period2End) {
    
    PeriodComparison comparison = historicalAnalyticsService.comparePeriods(
        companyId, period1Start, period1End, period2Start, period2End);
    return ResponseEntity.ok(ApiResponse.success("Period comparison retrieved", comparison));
}

@GetMapping("/historical/anomalies")
@Operation(summary = "Detect anomalies in historical data")
public ResponseEntity<ApiResponse<List<Anomaly>>> detectAnomalies(
    @RequestParam Long companyId,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate,
    @RequestParam AnomalyType type) {
    
    List<Anomaly> anomalies = historicalAnalyticsService.detectAnomalies(
        companyId, startDate, endDate, type);
    return ResponseEntity.ok(ApiResponse.success("Anomalies detected", anomalies));
}

@GetMapping("/historical/forecast")
@Operation(summary = "Forecast future metrics")
public ResponseEntity<ApiResponse<ForecastResult>> forecastMetrics(
    @RequestParam Long companyId,
    @RequestParam MetricType metricType,
    @RequestParam(defaultValue = "30") Integer daysAhead) {
    
    ForecastResult forecast = historicalAnalyticsService.forecastMetrics(
        companyId, metricType, daysAhead);
    return ResponseEntity.ok(ApiResponse.success("Forecast retrieved", forecast));
}

@GetMapping("/historical/fleet-health-trend")
@Operation(summary = "Get fleet health score trend")
public ResponseEntity<ApiResponse<HealthScoreTrend>> getFleetHealthTrend(
    @RequestParam Long companyId,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
    @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
    
    HealthScoreTrend trend = historicalAnalyticsService.getFleetHealthTrend(
        companyId, startDate, endDate);
    return ResponseEntity.ok(ApiResponse.success("Health trend retrieved", trend));
}
```

---

## 5. Frontend Integration

### 5.1 Historical Analytics Dashboard

**Create New Page:** `frontend/src/pages/HistoricalAnalyticsPage.tsx`

**Features:**
- Date range selector (predefined: Last 7 days, Last 30 days, Last 3 months, Last year, Custom)
- Metric selector (Cost, Utilization, Efficiency, Maintenance)
- Trend visualizations (Line charts, Area charts)
- Period comparison cards
- Anomaly alerts
- Forecast predictions

### 5.2 Trend Visualization Components

**Create:** `frontend/src/components/analytics/TrendChart.tsx`
- Configurable time series chart
- Multiple metrics on same chart
- Zoom and pan capabilities
- Export to CSV/PNG

**Create:** `frontend/src/components/analytics/PeriodComparisonCard.tsx`
- Side-by-side metric comparison
- Percentage change indicators
- Up/down arrows for visual clarity

**Create:** `frontend/src/components/analytics/AnomalyAlert.tsx`
- List of detected anomalies
- Severity indicators
- Quick action buttons

---

## 6. Forecasting Algorithms

### 6.1 Simple Moving Average (SMA)

**Use Case:** Short-term forecasting with stable patterns

```java
public ForecastResult simpleMovingAverage(List<Double> values, int windowSize, int daysAhead) {
    // Calculate average of last N values
    double sum = values.stream()
        .skip(Math.max(0, values.size() - windowSize))
        .mapToDouble(Double::doubleValue)
        .sum();
    
    double forecast = sum / Math.min(windowSize, values.size());
    
    // Repeat forecast for all days ahead
    List<Double> forecasts = Collections.nCopies(daysAhead, forecast);
    
    return ForecastResult.builder()
        .forecasts(forecasts)
        .confidence(calculateConfidence(values, forecast))
        .build();
}
```

### 6.2 Linear Regression

**Use Case:** Identifying linear trends

```java
public ForecastResult linearRegression(List<Double> values, int daysAhead) {
    // Calculate slope and intercept
    SimpleRegression regression = new SimpleRegression();
    for (int i = 0; i < values.size(); i++) {
        regression.addData(i, values.get(i));
    }
    
    // Predict future values
    List<Double> forecasts = new ArrayList<>();
    for (int i = 0; i < daysAhead; i++) {
        double prediction = regression.predict(values.size() + i);
        forecasts.add(prediction);
    }
    
    return ForecastResult.builder()
        .forecasts(forecasts)
        .confidence(regression.getRSquare())
        .build();
}
```

### 6.3 Exponential Smoothing

**Use Case:** Time series with trend and seasonality

```java
public ForecastResult exponentialSmoothing(List<Double> values, double alpha, int daysAhead) {
    // Initialize with first value
    double st = values.get(0);
    
    // Apply exponential smoothing
    for (int i = 1; i < values.size(); i++) {
        st = alpha * values.get(i) + (1 - alpha) * st;
    }
    
    // Forecast (constant value for simple exponential smoothing)
    List<Double> forecasts = Collections.nCopies(daysAhead, st);
    
    return ForecastResult.builder()
        .forecasts(forecasts)
        .confidence(calculateConfidence(values, st))
        .build();
}
```

---

## 7. Anomaly Detection Algorithms

### 7.1 Z-Score Method

**Use Case:** Detecting statistical outliers

```java
public List<Anomaly> detectAnomaliesZScore(List<FleetSummary> summaries, double threshold) {
    // Calculate mean and standard deviation
    double mean = summaries.stream()
        .mapToDouble(s -> s.getTotalCost().doubleValue())
        .average()
        .orElse(0.0);
    
    double stdDev = calculateStdDev(summaries, mean);
    
    // Identify outliers
    List<Anomaly> anomalies = new ArrayList<>();
    for (FleetSummary summary : summaries) {
        double zScore = Math.abs((summary.getTotalCost().doubleValue() - mean) / stdDev);
        if (zScore > threshold) {
            anomalies.add(Anomaly.builder()
                .date(summary.getSummaryDate())
                .type(AnomalyType.COST_SPIKE)
                .severity(zScore > 3 ? Severity.HIGH : Severity.MEDIUM)
                .actualValue(summary.getTotalCost())
                .expectedValue(BigDecimal.valueOf(mean))
                .deviation(BigDecimal.valueOf(zScore))
                .build());
        }
    }
    
    return anomalies;
}
```

### 7.2 Interquartile Range (IQR) Method

**Use Case:** Robust outlier detection

```java
public List<Anomaly> detectAnomaliesIQR(List<FleetSummary> summaries) {
    // Sort values
    List<Double> values = summaries.stream()
        .map(s -> s.getTotalCost().doubleValue())
        .sorted()
        .collect(Collectors.toList());
    
    // Calculate Q1, Q3, IQR
    double q1 = calculatePercentile(values, 25);
    double q3 = calculatePercentile(values, 75);
    double iqr = q3 - q1;
    
    // Define bounds
    double lowerBound = q1 - 1.5 * iqr;
    double upperBound = q3 + 1.5 * iqr;
    
    // Identify outliers
    List<Anomaly> anomalies = new ArrayList<>();
    for (FleetSummary summary : summaries) {
        double value = summary.getTotalCost().doubleValue();
        if (value < lowerBound || value > upperBound) {
            anomalies.add(createAnomaly(summary, value, q1, q3));
        }
    }
    
    return anomalies;
}
```

---

## 8. Performance Considerations

### 8.1 Data Volume Challenges

**Problem:** As historical data grows, queries become slower

**Solutions:**
1. **Partitioning:** Partition tables by date (monthly or quarterly)
2. **Aggregation:** Pre-calculate daily/monthly aggregates
3. **Caching:** Cache frequently accessed historical data
4. **Archival:** Move old detailed data to archive tables

### 8.2 Query Optimization

**Indexes:**
```sql
-- Ensure proper indexes exist
CREATE INDEX idx_fleet_summary_date_range 
ON fleet_summaries(company_id, summary_date);

CREATE INDEX idx_trips_vehicle_date 
ON trips(vehicle_id, start_time);

CREATE INDEX idx_charging_vehicle_date 
ON charging_sessions(vehicle_id, start_time);
```

**Materialized Views:**
```sql
-- Monthly aggregates for faster queries
CREATE MATERIALIZED VIEW monthly_fleet_summary AS
SELECT 
    company_id,
    DATE_TRUNC('month', summary_date) as month,
    SUM(total_cost) as total_cost,
    SUM(total_distance) as total_distance,
    AVG(active_vehicles) as avg_active_vehicles
FROM fleet_summaries
GROUP BY company_id, DATE_TRUNC('month', summary_date);

-- Refresh monthly
REFRESH MATERIALIZED VIEW monthly_fleet_summary;
```

### 8.3 Async Processing

**For Heavy Calculations:**
```java
@Async
public CompletableFuture<ForecastResult> forecastMetricsAsync(
    Long companyId, MetricType metricType, Integer daysAhead) {
    
    ForecastResult result = forecastMetrics(companyId, metricType, daysAhead);
    return CompletableFuture.completedFuture(result);
}
```

---

## 9. Implementation Recommendations

### Phase 1: Database Enhancement (Priority: HIGH)
1. Create historical tables (vehicle_state_history, cost_history, utilization_history)
2. Add indexes for performance
3. Create materialized views for common aggregations
4. Estimated Time: 8 hours

### Phase 2: Data Aggregation Jobs (Priority: HIGH)
1. Implement daily aggregation job
2. Implement data archival job
3. Test with historical data
4. Estimated Time: 12 hours

### Phase 3: Service Layer - Basic (Priority: HIGH)
1. Implement trend analysis methods
2. Implement period comparison
3. Add unit tests
4. Estimated Time: 16 hours

### Phase 4: Service Layer - Advanced (Priority: MEDIUM)
1. Implement forecasting algorithms
2. Implement anomaly detection
3. Add integration tests
4. Estimated Time: 20 hours

### Phase 5: API Layer (Priority: HIGH)
1. Add API endpoints
2. Add request validation
3. Add error handling
4. Estimated Time: 8 hours

### Phase 6: Frontend (Priority: MEDIUM)
1. Create Historical Analytics page
2. Create trend visualization components
3. Integrate with backend APIs
4. Estimated Time: 16 hours

### Phase 7: Optimization (Priority: LOW)
1. Implement caching
2. Optimize queries
3. Add async processing
4. Estimated Time: 12 hours

**Total Estimated Effort:** 92 hours (11-12 days)

---

## 10. Testing Requirements

### Unit Tests
- Trend calculation accuracy
- Forecasting algorithm accuracy
- Anomaly detection accuracy
- Statistical calculations

### Integration Tests
- End-to-end historical analysis
- API endpoint responses
- Data aggregation jobs
- Query performance

### Performance Tests
- Large dataset queries (5+ years of data)
- Concurrent historical analysis requests
- Aggregation job performance

---

## 11. Dependencies and Prerequisites

### Required:
- ✅ Historical data tables exist (fleet_summaries, trips, etc.)
- ⚠️ Need to create additional historical tables
- ⚠️ Need to implement aggregation jobs
- ⚠️ Need forecasting and anomaly detection logic

### Optional:
- Apache Commons Math (for statistical calculations)
- Time series analysis library (if using advanced forecasting)
- Machine learning library (for predictive analytics)

---

## Summary

Historical data analysis is **partially implemented** with data collection in place, but lacks the analytical capabilities needed for strategic fleet management. The system collects rich historical data but doesn't provide insights, trends, or predictions.

Implementing comprehensive historical analytics requires:
1. Creating additional historical tables for granular tracking
2. Building daily aggregation jobs for performance
3. Implementing trend analysis, forecasting, and anomaly detection
4. Adding API endpoints and frontend visualizations
5. Optimizing queries for large datasets

This is a **high-value feature** for strategic planning and should be implemented alongside E4 (TCO), E5 (Energy Tracking), and E6 (PDF Generation). Together, these features transform the platform from a monitoring tool to a strategic fleet management system.

**Recommendation:** Implement in phases, starting with trend analysis and period comparison (most immediately useful), then add forecasting and anomaly detection (more advanced).
